#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
gi_util.py
General utilities:
- parse .geom to get 'res' (resolution) for px<->mm conversion
- px_to_mm helpers
- golden-angle direction generator
- .lst writer
- simple JSONL logger
- indexamajig runner
"""

from __future__ import annotations
import os
import re
import shlex
import subprocess
import time
from dataclasses import dataclass
from typing import Iterable, List, Sequence, Tuple, Optional, Dict, Any


# ---------- Geom parsing and units ----------

_RES_PATTERNS = [
    re.compile(r"^\s*res(?:olution)?\s*[:=]\s*([0-9]*\.?[0-9]+)\s*$", re.IGNORECASE),
    # add more patterns if your geom uses another key
]

def read_geom_res_mm_per_1000px(geom_path: str) -> float:
    """
    Returns 'res' as used in your code, so that mm_per_px = 1000.0 / res.
    """
    with open(geom_path, "r") as f:
        for line in f:
            for pat in _RES_PATTERNS:
                m = pat.match(line)
                if m:
                    return float(m.group(1))
    raise ValueError(f"Could not find 'res' in geom: {geom_path}")


def mm_per_px(geom_res_value: float) -> float:
    """Convert your geom 'res' to mm/px as you specified: 1000/res."""
    return 1000.0 / float(geom_res_value)


def px_to_mm(dx_px: float, dy_px: float, geom_res_value: float) -> Tuple[float, float]:
    s = mm_per_px(geom_res_value)
    return dx_px * s, dy_px * s


# ---------- Golden-angle directions ----------

def golden_angle_radians() -> float:
    return 137.50776405003785 * 3.141592653589793 / 180.0


def ring_directions(K_dir: int, k0: int = 0) -> List[float]:
    """
    Return K_dir angles (radians) in low-discrepancy order using golden-angle.
    k0 is a starting index to rotate sequence run-to-run if desired.
    """
    GA = golden_angle_radians()
    return [((k0 + k) * GA) % (2.0 * 3.141592653589793) for k in range(K_dir)]


# ---------- .lst helpers ----------

def write_lst(lst_path: str, overlay_path: str, indices: Sequence[int]) -> None:
    with open(lst_path, "w") as f:
        for i in indices:
            f.write(f"{overlay_path} //{int(i)}\n")


# ---------- JSONL logging ----------

def jsonl_append(path: str, obj: Dict[str, Any]) -> None:
    import json
    os.makedirs(os.path.dirname(os.path.abspath(path)), exist_ok=True)
    with open(path, "a") as f:
        f.write(json.dumps(obj, separators=(",", ":")) + "\n")


# ---------- indexamajig runner ----------

@dataclass
class RunResult:
    stream_path: str
    returncode: int
    elapsed_s: float
    stderr_tail: str

def _shlex_join(parts: List[str]) -> str:
    # py3.9+: shlex.join exists; keep a tiny reimpl to be safe
    return " ".join(shlex.quote(p) for p in parts)

def run_indexamajig(
    lst_path: str,
    geom_path: str,
    cell_path: str,
    out_stream_path: str,
    flags: Optional[List[str]] = None,
    log_jsonl_path: Optional[str] = None,
    run_script_path: Optional[str] = None,   # <-- NEW: where to write the .sh
    stderr_path: Optional[str] = None,       # <-- NEW: capture stderr to file
) -> int:
    """
    Execute indexamajig for a single run (one overlay + one .lst).
    Also emits a .sh reproducer if run_script_path is provided.

    Returns the indexamajig return code.
    """
    flags = flags or []
    cmd = ["indexamajig", "-i", lst_path, "-g", geom_path, "-p", cell_path, *flags]

    # Prepare stderr file
    if stderr_path is None:
        stderr_path = out_stream_path.replace(".stream", ".err")

    # Emit a .sh reproducer for convenience
    if run_script_path:
        # We redirect in the shell for exact reproduction
        script = f"""#!/usr/bin/env bash
set -euo pipefail

# Auto-generated by gi_util.run_indexamajig on {time.strftime('%Y-%m-%d %H:%M:%S')}
# Reproduce the run for this overlay/.lst
# LST:    {lst_path}
# GEOM:   {geom_path}
# CELL:   {cell_path}
# STREAM: {out_stream_path}
# STDERR: {stderr_path}

echo "indexamajig version:"
indexamajig --version || true
echo

CMD="{_shlex_join(cmd)}"
echo "$CMD"
# Run and capture outputs exactly as the engine did:
$CMD > {shlex.quote(out_stream_path)} 2> {shlex.quote(stderr_path)}
"""
        os.makedirs(os.path.dirname(run_script_path), exist_ok=True)
        with open(run_script_path, "w") as f:
            f.write(script)
        os.chmod(run_script_path, 0o755)

    # Now run for real (no shell), and capture to the same files
    os.makedirs(os.path.dirname(out_stream_path), exist_ok=True)
    with open(out_stream_path, "w") as out_f, open(stderr_path, "w") as err_f:
        proc = subprocess.Popen(cmd, stdout=out_f, stderr=err_f)
        rc = proc.wait()

    # Optional: log tail for quick triage
    if log_jsonl_path:
        try:
            tail = ""
            with open(stderr_path, "r", encoding="utf-8", errors="ignore") as ef:
                tail = "".join(ef.readlines()[-50:])
        except Exception:
            pass
        from json import dumps
        with open(log_jsonl_path, "a") as lj:
            lj.write(dumps({
                "ts": time.time(),
                "type": "run_end",
                "lst": lst_path,
                "geom": geom_path,
                "cell": cell_path,
                "stream": out_stream_path,
                "stderr": stderr_path,
                "returncode": rc,
                "stderr_tail": tail,
                "cmd": cmd,
                "reproducer": run_script_path or "",
            }) + "\n")

    return rc
